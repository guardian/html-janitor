{"version":3,"file":"html-janitor.min.js","mappings":"CAAA,SAAAA,EAAAC,GACA,kBAAAC,SAAAA,OAAAC,IACAD,OAAA,eAAAD,GACA,gBAAAG,SACAC,OAAAD,QAAAH,IAEAD,EAAAM,YAAAL,KAEAM,KAAA,WAMA,QAAAD,GAAAE,GACAD,KAAAC,OAAAA,EAKA,QAAAC,GAAAC,GACA,MAAA,KAAAC,EAAAC,QAAAF,EAAAG,UAIA,QAAAC,GAAAJ,GACA,MAAA,KAAAK,EAAAH,QAAAF,EAAAG,UAyGA,QAAAG,GAAAN,GACA,MAAAO,UAAAD,iBAAAN,EACAQ,WAAAC,UAAAD,WAAAE,aAAAF,WAAAG,aACA,MAAA,GAnHA,GAAAV,IAAA,IAAA,KAAA,KAAA,KAAA,MAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,OAKAI,GAAA,IAAA,IAAA,SAAA,IAAA,KAAA,MAAA,MAAA,IAAA,SAiHA,OA5GAT,GAAAgB,UAAAC,MAAA,SAAAC,GACA,GAAAC,GAAAR,SAAAS,cAAA,MAKA,OAJAD,GAAAE,UAAAH,EAEAjB,KAAAqB,UAAAH,GAEAA,EAAAE,WAGArB,EAAAgB,UAAAM,UAAA,SAAAC,GACA,GAAAC,GAAAd,EAAAa,GACAnB,EAAAoB,EAAAC,YACA,IAAArB,EAEA,EAAA,CACA,GAAAG,GAAAH,EAAAG,SAAAmB,cACAC,EAAA1B,KAAAC,OAAA0B,KAAArB,EAGA,KAAAH,EAAAyB,WAIA,GAAAzB,EAAA0B,WAAAC,KAAAC,UAAA,CAkBA,GAAA5B,EAAA0B,WAAAC,KAAAE,aAAA,CACAV,EAAAW,YAAA9B,GACAH,KAAAqB,UAAAC,EACA,OAGA,GACAY,GADAC,EAAA5B,EAAAJ,EAEAgC,KACAD,EAAAE,MAAArB,UAAAsB,KAAAC,KAAAnC,EAAAoC,WAAArC,GAGA,IAAAsC,GAAAL,GAAAD,EAIAO,IAAAnB,EAAAA,WACAoB,EACAxC,EAAAoB,IACApB,EAAAC,IACAsC,CAIA,KAAAzC,KAAAC,OAAA0B,KAAArB,IAAAkC,IAAAxC,KAAAC,OAAA0C,yBAAAD,EAAA,CAEA,GAAA,WAAAvC,EAAAG,UAAA,UAAAH,EAAAG,SACA,KAAAH,EAAAoC,WAAAK,OAAA,GACAtB,EAAAuB,aAAA1C,EAAAoC,WAAA,GAAApC,EAGAmB,GAAAW,YAAA9B,GAEAH,KAAAqB,UAAAC,EACA,OAIA,IAAA,GAAAwB,GAAA,EAAAA,EAAA3C,EAAA4C,WAAAH,OAAAE,GAAA,EAAA,CACA,GAAAE,GAAA7C,EAAA4C,WAAAD,GACAG,EAAAD,EAAAE,KAAAzB,cAGA0B,EAAAzB,EAAAuB,GACAG,GAAAD,EACAE,EAAAF,KAAA,GAAAH,EAAAM,QAAAH,GACAC,GAAAC,KACAlD,EAAAoD,gBAAAP,EAAAE,MAEAJ,GAAA,GAKA9C,KAAAqB,UAAAlB,GAGAA,EAAAyB,YAAA,MArEA,IAAA,KAAAzB,EAAAqD,KAAAC,SACAtD,EAAAuD,wBAAAxD,EAAAC,EAAAuD,yBACAvD,EAAAwD,oBAAAzD,EAAAC,EAAAwD,qBAAA,CACArC,EAAAW,YAAA9B,GACAH,KAAAqB,UAAAC,EACA,cAiEAnB,EAAAoB,EAAAqC,gBASA7D","sources":["../src/html-janitor.js"],"sourcesContent":["(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('html-janitor', factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.HTMLJanitor = factory();\n  }\n}(this, function () {\n\n  /**\n   * @param {Object} config.tags Dictionary of allowed tags.\n   * @param {boolean} config.keepNestedBlockElements Default false.\n   */\n  function HTMLJanitor(config) {\n    this.config = config;\n  }\n\n  // TODO: not exhaustive?\n  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];\n  function isBlockElement(node) {\n    return blockElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];\n  function isInlineElement(node) {\n    return inlineElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  HTMLJanitor.prototype.clean = function (html) {\n    var sandbox = document.createElement('div');\n    sandbox.innerHTML = html;\n\n    this._sanitize(sandbox);\n\n    return sandbox.innerHTML;\n  };\n\n  HTMLJanitor.prototype._sanitize = function (parentNode) {\n    var treeWalker = createTreeWalker(parentNode);\n    var node = treeWalker.firstChild();\n    if (!node) { return; }\n\n    do {\n      var nodeName = node.nodeName.toLowerCase();\n      var allowedAttrs = this.config.tags[nodeName];\n\n      // Ignore nodes that have already been sanitized\n      if (node._sanitized) {\n        continue;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE) {\n        // If this text node is just whitespace and the previous or next element\n        // sibling is a block element, remove it\n        // N.B.: This heuristic could change. Very specific to a bug with\n        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output\n        // FIXME: make this an option?\n        if (node.data.trim() === ''\n            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))\n                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {\n          parentNode.removeChild(node);\n          this._sanitize(parentNode);\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      // Remove all comments\n      if (node.nodeType === Node.COMMENT_NODE) {\n        parentNode.removeChild(node);\n        this._sanitize(parentNode);\n        break;\n      }\n\n      var isInline = isInlineElement(node);\n      var containsBlockElement;\n      if (isInline) {\n        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);\n      }\n\n      var isInvalid = isInline && containsBlockElement;\n\n      // Block elements should not be nested (e.g. <li><p>...); if\n      // they are, we want to unwrap the inner block element.\n      var isNotTopContainer = !! parentNode.parentNode;\n      var isNestedBlockElement =\n            isBlockElement(parentNode) &&\n            isBlockElement(node) &&\n            isNotTopContainer;\n\n      // Drop tag entirely according to the whitelist *and* if the markup\n      // is invalid.\n      if (!this.config.tags[nodeName] || isInvalid || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {\n        // Do not keep the inner text of SCRIPT/STYLE elements.\n        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {\n          while (node.childNodes.length > 0) {\n            parentNode.insertBefore(node.childNodes[0], node);\n          }\n        }\n        parentNode.removeChild(node);\n\n        this._sanitize(parentNode);\n        break;\n      }\n\n      // Sanitize attributes\n      for (var a = 0; a < node.attributes.length; a += 1) {\n        var attr = node.attributes[a];\n        var attrName = attr.name.toLowerCase();\n\n        // Allow attribute?\n        var allowedAttrValue = allowedAttrs[attrName];\n        var notInAttrList = ! allowedAttrValue;\n        var valueNotAllowed = allowedAttrValue !== true && attr.value !== allowedAttrValue;\n        if (notInAttrList || valueNotAllowed) {\n          node.removeAttribute(attr.name);\n          // Shift the array to continue looping.\n          a = a - 1;\n        }\n      }\n\n      // Sanitize children\n      this._sanitize(node);\n\n      // Mark node as sanitized so it's ignored in future runs\n      node._sanitized = true;\n    } while ((node = treeWalker.nextSibling()));\n  };\n\n  function createTreeWalker(node) {\n    return document.createTreeWalker(node,\n                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n                                     null, false);\n  }\n\n  return HTMLJanitor;\n\n}));\n\n"],"names":["root","factory","define","amd","exports","module","HTMLJanitor","this","config","isBlockElement","node","blockElementNames","indexOf","nodeName","isInlineElement","inlineElementNames","createTreeWalker","document","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","SHOW_COMMENT","prototype","clean","html","sandbox","createElement","innerHTML","_sanitize","parentNode","treeWalker","firstChild","toLowerCase","allowedAttrs","tags","_sanitized","nodeType","Node","TEXT_NODE","COMMENT_NODE","removeChild","containsBlockElement","isInline","Array","some","call","childNodes","isInvalid","isNotTopContainer","isNestedBlockElement","keepNestedBlockElements","length","insertBefore","a","attributes","attr","attrName","name","allowedAttrValue","notInAttrList","valueNotAllowed","value","removeAttribute","data","trim","previousElementSibling","nextElementSibling","nextSibling"]}